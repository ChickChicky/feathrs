#![allow(unused_braces)]

use std::{
    net::{
        TcpListener,
        TcpStream
    },
    io::{
        prelude::*,
        BufReader,
        BufWriter
    },
    thread::{
        self
    }
};

#[derive(Clone)]
struct RequestTop {
    pub method: String,
    pub path: String,
    pub httpver: String,
    pub rest: String,
}

impl RequestTop {
    fn parse(top:String) -> Option<Self> {
        let mut method: String = "".to_string();
        let mut path: String = "".to_string();
        let mut httpver: String = "".to_string();
        let mut rest: String = "".to_string();
        let mut state: u8 = 0;
        for c in top.bytes() {
            if state == 0 {
                if c == b' ' {
                    state = 1;
                } else {
                    method.push(c as char);
                }
            }
            else if state == 1 {
                if c == b' ' {
                    state = 2;
                } else {
                    path.push(c as char);
                }
            }
            else if state == 2 {
                if c == b' ' {
                    state = 3;
                } else {
                    httpver.push(c as char);
                }
            }
            else if state == 3 {
                rest.push(c as char);
            }
        }
        if method == "" || path == "" || httpver == "" {
            return None;
        }
        Some(Self {
            method, path, httpver, rest
        })
    }
}

struct HttpRequest<'a> {
    pub body: String,
    
    pub path: String,
    pub httpver: String,
    pub method: String,
    pub toprest: String,

    pub conn: &'a TcpStream,
}

struct HttpResponse {
    pub status_code: u32,
    pub status_message: String,
    pub body: String,
}

impl HttpResponse {
    fn Ok(body:String) -> Self {
        Self {
            status_code: 200, status_message: "OK".to_string(),
            body
        }
    }
    fn NotFound(body:String) -> Self {
        Self {
            status_code: 404, status_message: "Not Found".to_string(),
            body
        }
    }
    fn to_string(self) -> String {
        return format!("HTTP/1.1 {} {}\r\n{}\r\n\r\n{}",self.status_code,self.status_message,""/*headers*/,self.body).to_string();
    }
}

impl<'a> HttpRequest<'a> {
    fn new(stream: &'a mut TcpStream) -> Result<Self,String> {
        let reader: BufReader<&mut TcpStream> = BufReader::new(stream);
        let mut headers: Vec<String> = reader.lines().map(|line: Result<String, std::io::Error>|line.unwrap()).take_while(|line: &String|!line.is_empty()).collect();
        if let Some(top) = RequestTop::parse(headers.remove(0)) {
            if headers.len() == 0 { return Err("Invalid headers".to_string()); }
            if let Some(top) = RequestTop::parse(headers.remove(0)) {
                if top.httpver != "HTTP/1.1" { return Err("Unsupported HTTP version".to_string()); }
                return Ok( Self {
                    path: top.path,
                    httpver: top.httpver,
                    method: top.method,
                    toprest: top.rest,
                    conn: stream,
                    body: "".to_string()
                } );
            }
        }
        Err(format!("Failed to parse request headers\n{}").to_string())
    }
}

fn accept_client( orig_conn: TcpStream ) {

    let mut conn: TcpStream = orig_conn.try_clone().expect("Could not clone TCP stream.");
    thread::spawn(move||{
        match HttpRequest::new(&mut conn) {
            Ok( req ) => {
                conn.write_all(HttpResponse::Ok("<!DOCTYPE HTML><html><body>Hello</body></html>".to_string()).to_string().as_bytes()).unwrap();
            },
            Err( e ) => {
                println!("{:?}",e);
            }
        }
    });

}

fn main() {
    
    let listener: TcpListener = TcpListener::bind("0.0.0.0:4243").unwrap();

    for stream in listener.incoming() {
        let stream: TcpStream = stream.unwrap();
        accept_client(stream);
    }

}
